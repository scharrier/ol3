// This file is automatically generated, do not edit
goog.provide('ol.renderer.webgl.VectorRenderShader');
goog.require('ol.webgl.shader');
/**
 * @constructor
 * @extends {ol.webgl.shader.Fragment}
 * @param {WebGLRenderingContext=} opt_gl GL.
 */
ol.renderer.webgl.VectorRenderShaderFragment = function(opt_gl) {
  var source = ol.renderer.webgl.VectorRenderShaderFragment.SOURCE;
  if (goog.isDef(opt_gl)) {
    source = ol.renderer.webgl.VectorRenderShader.sourcePreamble_(opt_gl) + source;
  }
  goog.base(this, source);
};
goog.inherits(ol.renderer.webgl.VectorRenderShaderFragment, ol.webgl.shader.Fragment);
goog.addSingletonGetter(ol.renderer.webgl.VectorRenderShaderFragment);
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.VectorRenderShaderFragment.DEBUG_SOURCE = '//! NAMESPACE=ol.renderer.webgl.VectorRenderShader\n//! CLASS=ol.renderer.webgl.VectorRenderShader\n\n//! COMMON\n\n\n//! FRAGMENT\n//! JSCONST PREMULTIPLY_BY_ALPHA Number(gl.getContextAttributes().premultipliedAlpha)\n\nprecision mediump float;\n\n// ---- Interface\n\nuniform vec3 RenderParams;\nfloat antiAliasing = RenderParams.x;\nfloat gamma = RenderParams.y;\nfloat rcpGamma = RenderParams.z;\n\nvarying vec3 Surface_Opacity; // (2d coords, invalidate, opacity)\nvarying vec4 Color_NegHorizSurfScale;\nvarying vec4 StrokeColor_Cutoff;\n\n// ---- Implementation\n\nfloat blendCoeff(vec2 edge0, vec2 edge1, vec2 x) {\n  vec2 weight = smoothstep(edge0, edge1, x);\n  return max(weight.x, weight.y);\n}\n\nvec3 gammaApply(vec3 color) {\n  return pow(clamp(color, 0.0, 1.0), vec3(gamma));\n}\n\nvec3 gammaCorrect(vec3 color) {\n  return pow(clamp(color, 0.0, 1.0), vec3(rcpGamma));\n}\n\n\nvoid main(void) {\n\n  // Distance from center of surface coordinate (keep it this way;\n  // strangely the \'abs\' function does not work correctly on all\n  // platforms here)\n  vec2 dist = min(Surface_Opacity.xy * sign(Surface_Opacity.xy), 1.0);\n\n  // Determine thresholds in surface coordinates\n  //\n  // 0.0         1.0\n  // |-----------------|\n  // \n  // +--- extent ---+\n  //     incl. aa / 2  :\n  //           :\n  //       |<------| stroke cutoff\n  //       :\n  //       |aa->\n  //       |---|\n  // inner edge min / max\n  // \n  //        |<-aa|\n  // outer edge min\n  //\n  float strokeCutoff = StrokeColor_Cutoff.w; // scaled stroke width\n\n#ifndef STANDARD_DERIVATIVES\n  vec2 negScale = vec2(\n      Color_NegHorizSurfScale.w, \n      -1.0 / max(strokeCutoff, antiAliasing));\n#else\n  // with this extension can determine the gradient length of\n  // each surface coordinate component in pixels\n  vec2 dSurfPixX = dFdx(Surface_Opacity.xy), dSurfPixY = dFdy(Surface_Opacity.xy);\n  vec2 negScale = vec2(\n      -length(vec2(dSurfPixX.x, dSurfPixY.x)),\n      -length(vec2(dSurfPixX.y, dSurfPixY.y)));\n  // FIXME Currently out of sync with scale requirements...\n#endif\n\n  vec2 negAntiAlias = negScale * antiAliasing;\n  vec2 innerEdgeMin = negScale * strokeCutoff + vec2(1.0);\n  vec2 innerEdgeMax = innerEdgeMin - negAntiAlias;\n  vec2 outerEdgeMin = negAntiAlias + vec2(1.0);\n\n  // Blend with stroke color (smooth, inner edge)\n  vec3 color = mix(\n      Color_NegHorizSurfScale.rgb, StrokeColor_Cutoff.rgb,\n      blendCoeff(innerEdgeMin, innerEdgeMax, dist));\n\n  // Adjust alpha for edge smoothing (outer edge)\n  float alpha = Surface_Opacity.z  * (1.0 - blendCoeff(outerEdgeMin, vec2(1.0), dist));\n\n  // Gamma correct here (for now - we\'d ideally want to blend in \n  // a linearized color space)\n  color = gammaCorrect(color);\n\n#if PREMULTIPLY_BY_ALPHA\n  color.rgb *= alpha;\n#endif\n  gl_FragColor = vec4(color, alpha);\n}\n\n\n';
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.VectorRenderShaderFragment.OPTIMIZED_SOURCE = 'precision mediump float;uniform vec3 d;float h=d.x;float i=d.y;float j=d.z;varying vec3 e;varying vec4 f,g;float v(vec2 k,vec2 l,vec2 m){vec2 n=smoothstep(k,l,m);return max(n.x,n.y);}vec3 w(vec3 k){return pow(clamp(k,0.,1.),vec3(j));}void main(){vec2 k,p,q,r,s;k=min(e.xy*sign(e.xy),1.);float l,u;l=g.w;\n#ifndef STANDARD_DERIVATIVES\nvec2 m=vec2(f.w,-1./max(l,h));\n#else\nvec2 n,o,m;n=dFdx(e.xy);o=dFdy(e.xy);m=vec2(-length(vec2(n.x,o.x)),-length(vec2(n.y,o.y)));\n#endif\np=m*h;q=m*l+vec2(1);r=q-p;s=p+vec2(1);vec3 t=mix(f.rgb,g.rgb,v(q,r,k));u=e.z*(1.-v(s,vec2(1),k));t=w(t);\n#if PREMULTIPLY_BY_ALPHA\nt.rgb*=u;\n#endif\ngl_FragColor=vec4(t,u);}';
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.VectorRenderShaderFragment.SOURCE = goog.DEBUG ?
    ol.renderer.webgl.VectorRenderShaderFragment.DEBUG_SOURCE :
    ol.renderer.webgl.VectorRenderShaderFragment.OPTIMIZED_SOURCE;
/**
 * @constructor
 * @extends {ol.webgl.shader.Vertex}
 * @param {WebGLRenderingContext=} opt_gl GL.
 */
ol.renderer.webgl.VectorRenderShaderVertex = function(opt_gl) {
  var source = ol.renderer.webgl.VectorRenderShaderVertex.SOURCE;
  if (goog.isDef(opt_gl)) {
    source = ol.renderer.webgl.VectorRenderShader.sourcePreamble_(opt_gl) + source;
  }
  goog.base(this, source);
};
goog.inherits(ol.renderer.webgl.VectorRenderShaderVertex, ol.webgl.shader.Vertex);
goog.addSingletonGetter(ol.renderer.webgl.VectorRenderShaderVertex);
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.VectorRenderShaderVertex.DEBUG_SOURCE = '//! NAMESPACE=ol.renderer.webgl.VectorRenderShader\n//! CLASS=ol.renderer.webgl.VectorRenderShader\n\n//! COMMON\n\n\n//! VERTEX\n\nprecision highp float;\n\n// ---- Interface\n\nattribute vec4 PositionP;\nattribute vec4 Position0;\nattribute vec4 PositionN;\nattribute float Control;\n\nattribute vec4 Style;\n// extent\n// color (rgb)\n// opacity (floor 0..255), outline width (fract)\n// stroke color (rgb)\n\nuniform vec4 Pretranslation;\nuniform mat4 Transform;\nuniform vec2 PixelScale;\n\nuniform vec3 RenderParams;\nfloat antiAliasing = RenderParams.x;\n//-float gamma = RenderParams.y; - used in fragment shader\n//-float rcpGamma = RenderParams.z; - used in fragment shader\n\nvarying vec3 Surface_Opacity;\nvarying vec4 Color_NegHorizSurfScale;\nvarying vec4 StrokeColor_Cutoff;\n\n\n// ---- Implementation\n\nvec4 pretranslate(vec4 highPrecEncodedCoord) {\n  vec4 v = highPrecEncodedCoord + Pretranslation;\n  v.xy += v.zw;\n  v.zw = vec2(0.0, 1.0);\n  return v;\n}\n\nvec3 decodeRGB(float v) {\n\n  const float downshift16 = 1. / 65536.;\n  const float downshift8  = 1. /   256.;\n\n  return vec3(fract(v * downshift16), \n    fract(v * downshift8), fract(v));\n}\n\nvec2 rotateCw(vec2 p) {\n  return vec2(p.y, -p.x);\n}\n\nvec2 rotateCcw(vec2 p) {\n  return vec2(-p.y, p.x);\n}\n\nvec3 perspDiv(vec4 p) {\n  return p.xyz / p.w;\n}\n\nvec2 safeNormalize(vec2 v) {\n  float frob = dot(v, v);\n  return v * (frob > 0.0 ? inversesqrt(frob) : 0.0);\n}\n\nvoid main(void) {\n\n  // Basic vertex shader operation\n  gl_Position = Transform * pretranslate(Position0);\n\n  // Decode colors and opacity from style\n  Color_NegHorizSurfScale.rgb = decodeRGB(Style.y);\n  StrokeColor_Cutoff.rgb = decodeRGB(Style.w);\n  float lineMode = max(sign(Style.z), 0.0);\n  float alphaAndWidth = Style.z * sign(Style.z);\n  Surface_Opacity = vec3(-lineMode, 0.0, floor(alphaAndWidth) / 255.0);\n\n  // Decode line widths from style and prepare for rendering\n  float extent = Style.x * (0.5 + lineMode * 0.5);\n  float actExtent = extent + antiAliasing * 0.5;\n  Color_NegHorizSurfScale.w = -1.0 / actExtent;\n  float strokeCutoff = fract(alphaAndWidth) * (extent + antiAliasing * 1.5);\n  StrokeColor_Cutoff.w = strokeCutoff;\n\n  if (Control >= 16.0) return;\n\n  // Perform additional transforms\n  vec2 pN = perspDiv(Transform * pretranslate(PositionN)).xy;\n  vec2 p0 = perspDiv(gl_Position).xy;\n  vec2 pP = perspDiv(Transform * pretranslate(PositionP)).xy;\n\n  // Determine tangents of adjacent edges and at vertex\n  vec2 tP = safeNormalize(p0 - pP);\n  vec2 tN = safeNormalize(pN - p0);\n\n  // Vertex normal when normalized or degenerates to tangent for line\n  // endings\n  vec2 normalOut = tP - tN;\n\n  // Determine extrusion / surface coordinates in tangential direction\n  // (only at start/end of a line strip, indicated via control flags)\n  float ctrl = Control;\n\n  float tangentialExtrusion = 0.0;\n  if (ctrl >= 8.0) {\n    ctrl -= 8.0;\n\n    // Displacement towards the outside of the line\n    tangentialExtrusion = max(strokeCutoff, antiAliasing);\n\n    // Let surface coordinate indicate the edge (can use the\n    // same value for both ends as interpolating towards zero in\n    // all cases - subdivision is inherent)\n    Surface_Opacity.y = 1.0;\n\n    actExtent *= -1.0;\n  }\n\n  // Surface coordinate\n  if (ctrl >= 4.0) {\n    ctrl -= 4.0;\n    Surface_Opacity.x = 1.0;\n    actExtent *= -1.0;\n  }\n\n  // Select source for extrusion in normal direction\n  vec2 normal = vec2(0.0);\n  if (ctrl == 0.0) {\n    normal = rotateCcw(tP);\n  } else if (ctrl == 2.0) {\n    normal = rotateCcw(tN);\n  } else if (ctrl == 1.0 || ctrl == 3.0) {\n    normal = normalize(normalOut);\n    actExtent = (ctrl - 2.0) * abs(actExtent  /\n            dot(normal, rotateCcw(tP)));\n  } \n\n  vec2 displacement = tangentialExtrusion * normalOut + actExtent * normal; \n  gl_Position.xy += gl_Position.w * displacement * PixelScale;\n}\n\n';
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.VectorRenderShaderVertex.OPTIMIZED_SOURCE = 'precision highp float;attribute vec4 h,i,j,l;attribute float k;uniform vec4 a;uniform mat4 b;uniform vec2 c;uniform vec3 d;float m=d.x;varying vec3 e;varying vec4 f,g;vec4 C(vec4 n){vec4 o=n+a;o.xy+=o.zw;o.zw=vec2(0,1);return o;}vec3 D(float n){const float o=1./65536.;const float p=1./256.;return vec3(fract(n*o),fract(n*p),fract(n));}vec2 E(vec2 n){return vec2(-n.y,n.x);}vec3 F(vec4 n){return n.xyz/n.w;}vec2 G(vec2 n){float o=dot(n,n);return n*(o>0.?inversesqrt(o):0.);}void main(){gl_Position=b*C(i);f.rgb=D(l.y);g.rgb=D(l.w);float n,o,p,q,r,y,z;n=max(sign(l.z),0.);o=l.z*sign(l.z);e=vec3(-n,0,floor(o)/255.);p=l.x*(.5+n*.5);q=p+m*.5;f.w=-1./q;r=fract(o)*(p+m*1.5);g.w=r;if(k>=16.)return;vec2 s,t,u,v,w,x,A,B;s=F(b*C(j)).xy;t=F(gl_Position).xy;u=F(b*C(h)).xy;v=G(t-u);w=G(s-t);x=v-w;y=k;z=0.;if(y>=8.){y-=8.;z=max(r,m);e.y=1.;q*=-1.;}if(y>=4.){y-=4.;e.x=1.;q*=-1.;}A=vec2(0);if(y==0.)A=E(v);else if(y==2.)A=E(w);else if(y==1.||y==3.){A=normalize(x);q=(y-2.)*abs(q/dot(A,E(v)));}B=z*x+q*A;gl_Position.xy+=gl_Position.w*B*c;}';
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.VectorRenderShaderVertex.SOURCE = goog.DEBUG ?
    ol.renderer.webgl.VectorRenderShaderVertex.DEBUG_SOURCE :
    ol.renderer.webgl.VectorRenderShaderVertex.OPTIMIZED_SOURCE;
/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 */
ol.renderer.webgl.VectorRenderShader.Locations = function(gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.Pretranslation = gl.getUniformLocation(
      program, goog.DEBUG ? 'Pretranslation' : 'a');
  /**
   * @type {WebGLUniformLocation}
   */
  this.Transform = gl.getUniformLocation(
      program, goog.DEBUG ? 'Transform' : 'b');
  /**
   * @type {WebGLUniformLocation}
   */
  this.PixelScale = gl.getUniformLocation(
      program, goog.DEBUG ? 'PixelScale' : 'c');
  /**
   * @type {WebGLUniformLocation}
   */
  this.RenderParams = gl.getUniformLocation(
      program, goog.DEBUG ? 'RenderParams' : 'd');
  /**
   * @type {number}
   */
  this.PositionP = gl.getAttribLocation(
      program, goog.DEBUG ? 'PositionP' : 'h');
  /**
   * @type {number}
   */
  this.Position0 = gl.getAttribLocation(
      program, goog.DEBUG ? 'Position0' : 'i');
  /**
   * @type {number}
   */
  this.PositionN = gl.getAttribLocation(
      program, goog.DEBUG ? 'PositionN' : 'j');
  /**
   * @type {number}
   */
  this.Control = gl.getAttribLocation(
      program, goog.DEBUG ? 'Control' : 'k');
  /**
   * @type {number}
   */
  this.Style = gl.getAttribLocation(
      program, goog.DEBUG ? 'Style' : 'l');
};
/**
 * Generates a source preamble from the expressions in JSCONST
 * directives.
 * We have the rendering context passed in to allow querying
 * extensions and context attributes.
 *
 * @private
 * @param {WebGLRenderingContext} gl GL.
 * @return {string} Shader source preamble.
 */
ol.renderer.webgl.VectorRenderShader.sourcePreamble_ = function(gl) {
  return (
      '\n#define ' +
        (goog.DEBUG ? 'PREMULTIPLY_BY_ALPHA' : 'PREMULTIPLY_BY_ALPHA') +
        ' ' + (Number(gl.getContextAttributes().premultipliedAlpha)) +
'\n');
};
