// This file is automatically generated, do not edit
goog.provide('ol.renderer.webgl.vectorlayer2.shader.LineStringCollection');
goog.require('ol.webgl.shader');
/**
 * @constructor
 * @extends {ol.webgl.shader.Fragment}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment = function() {
  goog.base(this, ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment.SOURCE);
};
goog.inherits(ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment, ol.webgl.shader.Fragment);
goog.addSingletonGetter(ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment);
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment.DEBUG_SOURCE = 'precision mediump float;\n//! NAMESPACE=ol.renderer.webgl.vectorlayer2.shader.LineStringCollection\n//! CLASS=ol.renderer.webgl.vectorlayer2.shader.LineStringCollection\n\n\n//! COMMON\n//#version 100 // FIXME we should be able to uncomment this\n#define PREMULTIPLY_BY_ALPHA true\n\n\n//! FRAGMENT\n\n// ---- Configuration\n\nprecision mediump float;\n\n// ---- Interface\n\nvarying vec2 Surface;\nvarying float Invalidate;\n\nvarying vec2 v_Style;\n//- float lineWidth = v_Style.x;\n//- float outlineWidth = v_Style.y;\n\nconst vec4 FillColor = vec4(1.,0.,0.,1.);\nconst vec4 StrokeColor = vec4(1.,1.,0.,1.);\n\n//uniform vec3 RenderParams;\nconst vec3 RenderParams = vec3(1.75, 2.3, 1./2.3);\nfloat antiAliasing = RenderParams.x;\nfloat gamma = RenderParams.y;\nfloat rcpGamma = RenderParams.z;\n\n\n\n// ---- Implementation\n\nfloat blendCoeff(vec2 edge0, vec2 edge1, vec2 x) {\n    vec2 weight = smoothstep(edge0, edge1, x);\n    return max(weight.x, weight.y);\n}\n\nvec3 gammaApply(vec3 color) {\n    return pow(clamp(color, 0.0, 1.0), vec3(gamma));\n}\n\nvec3 gammaCorrect(vec3 color) {\n    return pow(clamp(color, 0.0, 1.0), vec3(rcpGamma));\n}\n\n\nvoid main(void) {\n\n    if (Invalidate > 0.0) discard;\n\n    // Distance from center of surface coordinate (keep it this way;\n    // strangely the \'abs\' function does not work correctly on all\n    // platforms here)\n    vec2 dist = min(Surface * sign(Surface), 1.0);\n\n    // Determine thresholds in surface coordinates\n    //\n    // 0.0             1.0\n    // |-----------------|\n    // \n    // +--- extent ---+\n    //         + aa / 2  :\n    //                   :\n    //           |<------|\n    //           : stroke\n    //           |aa->\n    //           |---|\n    // inner edge min / max\n    // \n    //              |<-aa|\n    // outer edge min\n    //\n    float extent = v_Style.x; // includes aa/2\n    float outlineWidth = v_Style.y; // scaled in vertex shader\n\n#ifndef STANDARD_DERIVATIVES\n    vec2 negScale = vec2(-1.0 / extent, \n                         -1.0 / max(outlineWidth, antiAliasing));\n#else\n    // with this extension can determine the gradient length of\n    // each surface coordinate component in pixels\n    vec2 dSurfPixX = dFdx(Surface), dSurfPixY = dFdy(Surface);\n    vec2 negScale = vec2(-length(vec2(dSurfPixX.x, dSurfPixY.x)),\n                         -length(vec2(dSurfPixX1.y, dSurfPixY.y)));\n#endif\n\n    vec2 negAntiAlias = negScale * antiAliasing;\n    vec2 innerEdgeMin = negScale * outlineWidth + vec2(1.0);\n    vec2 innerEdgeMax = innerEdgeMin - negAntiAlias;\n    vec2 outerEdgeMin = negAntiAlias + vec2(1.0);\n\n    // Blend with stroke color (smooth, inner edge)\n    vec4 color = mix(FillColor, StrokeColor,\n                     blendCoeff(innerEdgeMin, innerEdgeMax, dist));\n\n    // Adjust alpha for edge smoothing (outer edge)\n    color.a = color.a * (1.0 - blendCoeff(outerEdgeMin, vec2(1.0), dist));\n\n    // Gamma correct here (for now - we\'d ideally want to blend in \n    // a linearized color space)\n    color.rgb = gammaCorrect(color.rgb);\n\n#ifdef PREMULTIPLY_BY_ALPHA\n    color.rgb *= color.a;\n#endif\n\n    gl_FragColor = color;\n}\n\n\n';
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment.OPTIMIZED_SOURCE = 'precision mediump float;#define PREMULTIPLY_BY_ALPHA true\nprecision mediump float;varying vec2 d,c;varying float e;const vec4 f=vec4(1,0,0,1);const vec4 g=vec4(1,1,0,1);const vec3 h=vec3(1.75,2.3,1./2.3);float i=h.x;float j=h.y;float k=h.z;float w(vec2 l,vec2 m,vec2 n){vec2 o=smoothstep(l,m,n);return max(o.x,o.y);}vec3 x(vec3 l){return pow(clamp(l,0.,1.),vec3(k));}void main(){if(e>0.)discard;vec2 l,r,s,t,u;l=min(d*sign(d),1.);float m,n;m=c.x;n=c.y;\n#ifndef STANDARD_DERIVATIVES\nvec2 o=vec2(-1./m,-1./max(n,i));\n#else\nvec2 p,q,o;p=dFdx(d);q=dFdy(d);o=vec2(-length(vec2(p.x,q.x)),-length(vec2(dSurfPixX1.y,q.y)));\n#endif\nr=o*i;s=o*n+vec2(1);t=s-r;u=r+vec2(1);vec4 v=mix(f,g,w(s,t,l));v.a=v.a*(1.-w(u,vec2(1),l));v.rgb=x(v.rgb);\n#ifdef PREMULTIPLY_BY_ALPHA\nv.rgb*=v.a;\n#endif\ngl_FragColor=v;}';
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment.SOURCE = goog.DEBUG ?
    ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment.DEBUG_SOURCE :
    ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment.OPTIMIZED_SOURCE;
/**
 * @constructor
 * @extends {ol.webgl.shader.Vertex}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex = function() {
  goog.base(this, ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex.SOURCE);
};
goog.inherits(ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex, ol.webgl.shader.Vertex);
goog.addSingletonGetter(ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex);
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex.DEBUG_SOURCE = '//! NAMESPACE=ol.renderer.webgl.vectorlayer2.shader.LineStringCollection\n//! CLASS=ol.renderer.webgl.vectorlayer2.shader.LineStringCollection\n\n\n//! COMMON\n//#version 100 // FIXME we should be able to uncomment this\n#define PREMULTIPLY_BY_ALPHA true\n\n\n//! VERTEX\n\n// ---- Configuration\n\nprecision mediump float;\n\n// ---- Interface\n\nattribute vec2 PositionP;\nattribute vec2 Position0;\nattribute vec2 PositionN;\nattribute float Control;\n\nattribute vec2 Style;\n//- float lineWidth = Style.x;\n\nuniform mat4 Transform;\nuniform vec2 PixelScale;\n\n//uniform vec3 RenderParams;\nconst float antiAliasing = 1.75; //RenderParams.x;\n\nvarying vec2 v_Style;\nvarying vec2 Surface;\nvarying float Invalidate;\n\n// ---- Implementation\n\nvec2 rotateCw(vec2 p) {\n    return vec2(p.y, -p.x);\n}\n\nvec3 perspDiv(vec4 p) {\n    return p.xyz / p.w;\n}\n\nvec2 safeNormalize(vec2 v) {\n    float frob = dot(v, v);\n    return v * (frob > 0.0 ? inversesqrt(frob) : 0.0);\n}\n\nvoid main(void) {\n\n    // Basic vertex shader operation\n    gl_Position = Transform * vec4(Position0, 0.0, 1.0);\n\n    if (Control == 12.0) {\n        Invalidate = 1.0;\n        return;\n    }\n\n    Invalidate = 0.0;\n    Surface = vec2(0.0, 0.0);\n\n    float extent = Style.x * 0.5;\n    float fractStrokeWidth = Style.y;\n    v_Style.x = extent + antiAliasing * 0.5;\n    v_Style.y = fractStrokeWidth * (extent + antiAliasing * 1.5);\n\n    // Done when not at edge, otherwise the above output\n    // provides default values assumed in the code below\n    if (Control == 0.0) return;\n\n    // Perform additional transforms\n    vec2 pN = perspDiv(Transform * vec4(PositionN, 0.0, 1.0)).xy;\n    vec2 p0 = perspDiv(gl_Position).xy;\n    vec2 pP = perspDiv(Transform * vec4(PositionP, 0.0, 1.0)).xy;\n\n    // Determine tangents of adjacent edges and at vertex\n    vec2 tP = safeNormalize(p0-pP);\n    vec2 tN = safeNormalize(pN-p0);\n    vec2 tangent = tP + tN;\n\n    vec2 displacement = vec2(0.0);\n\n    // Determine extrusion / surface coordinates in tangential direction\n    // (only at start/end of a line strip, indicated via control flags)\n    float ctrl = Control;\n    if (ctrl >= 4.0) {\n        // Vertical edge?\n\n        if (ctrl >= 8.0) {\n            ctrl -= 4.0; // bit removal - or half of it (see below)\n\n            // Tangent is in opposite direction - correect it\n            tangent = -tangent;\n\n            // Displacement towards the outside of the line\n            displacement = (tP - tN) * max(v_Style.y, antiAliasing);\n\n            // Let surface coordinate indicate the edge (can use the\n            // same value for both ends as interpolating towards zero in\n            // all cases - subdivision is inherent)\n            Surface.y = 1.0;\n        }\n\n        // Tangent used as reference for mitering is either in opposite\n        // direction or zero - correct it\n        tP = tangent;\n\n        ctrl -= 4.0; // bit removal - done odd to ease data dependencies\n    }\n\n    // Determine extrusion / surface coordinate in normal directions\n    vec2 normal = normalize(rotateCw(tangent));\n    Surface.x = ctrl * 2.0 - 3.0;\n    float horizExtent = v_Style.x /         // extent (line width / 2)\n            dot(rotateCw(tP), normal) *     // projected along miter\n            Surface.x;                      // sign: left or right\n\n    displacement += horizExtent * normal; \n    gl_Position.xy += gl_Position.w * displacement * PixelScale;\n}\n\n\n';
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex.OPTIMIZED_SOURCE = '#define PREMULTIPLY_BY_ALPHA true\nprecision mediump float;attribute vec2 f,g,h,j;attribute float i;uniform mat4 a;uniform vec2 b;const float k=1.75;varying vec2 c,d;varying float e;vec2 x(vec2 l){return vec2(l.y,-l.x);}vec3 y(vec4 l){return l.xyz/l.w;}vec2 z(vec2 l){float m=dot(l,l);return l*(m>0.?inversesqrt(m):0.);}void main(){gl_Position=a*vec4(g,0,1);if(i==12.){e=1.;return;}e=0.;d=vec2(0);float l,m,u,w;l=j.x*.5;m=j.y;c.x=l+k*.5;c.y=m*(l+k*1.5);if(i==0.)return;vec2 n,o,p,q,r,s,t,v;n=y(a*vec4(h,0,1)).xy;o=y(gl_Position).xy;p=y(a*vec4(f,0,1)).xy;q=z(o-p);r=z(n-o);s=q+r;t=vec2(0);u=i;if(u>=4.){if(u>=8.){u-=4.;s=-s;t=(q-r)*max(c.y,k);d.y=1.;}q=s;u-=4.;}v=normalize(x(s));d.x=u*2.-3.;w=c.x/dot(x(q),v)*d.x;t+=w*v;gl_Position.xy+=gl_Position.w*t*b;}';
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex.SOURCE = goog.DEBUG ?
    ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex.DEBUG_SOURCE :
    ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex.OPTIMIZED_SOURCE;
/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollection.Locations = function(gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.Transform = gl.getUniformLocation(
      program, goog.DEBUG ? 'Transform' : 'a');
  /**
   * @type {WebGLUniformLocation}
   */
  this.PixelScale = gl.getUniformLocation(
      program, goog.DEBUG ? 'PixelScale' : 'b');
  /**
   * @type {number}
   */
  this.PositionP = gl.getAttribLocation(
      program, goog.DEBUG ? 'PositionP' : 'f');
  /**
   * @type {number}
   */
  this.Position0 = gl.getAttribLocation(
      program, goog.DEBUG ? 'Position0' : 'g');
  /**
   * @type {number}
   */
  this.PositionN = gl.getAttribLocation(
      program, goog.DEBUG ? 'PositionN' : 'h');
  /**
   * @type {number}
   */
  this.Control = gl.getAttribLocation(
      program, goog.DEBUG ? 'Control' : 'i');
  /**
   * @type {number}
   */
  this.Style = gl.getAttribLocation(
      program, goog.DEBUG ? 'Style' : 'j');
};
