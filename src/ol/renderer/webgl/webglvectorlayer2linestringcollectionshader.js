// This file is automatically generated, do not edit
goog.provide('ol.renderer.webgl.vectorlayer2.shader.LineStringCollection');
goog.require('ol.webgl.shader');
/**
 * @constructor
 * @extends {ol.webgl.shader.Fragment}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment = function() {
  goog.base(this, ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment.SOURCE);
};
goog.inherits(ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment, ol.webgl.shader.Fragment);
goog.addSingletonGetter(ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment);
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment.DEBUG_SOURCE = 'precision mediump float;\n//! NAMESPACE=ol.renderer.webgl.vectorlayer2.shader.LineStringCollection\n//! CLASS=ol.renderer.webgl.vectorlayer2.shader.LineStringCollection\n\n\n//! COMMON\n//#version 100 // FIXME we should be able to uncomment this\n#define PREMULTIPLY_BY_ALPHA true\n\n\n//! FRAGMENT\n\n\n// ---- Configuration\n\nprecision mediump float;\n\n// ---- Interface\n\nuniform vec3 RenderParams;\nfloat antiAliasing = RenderParams.x;\nfloat gamma = RenderParams.y;\nfloat rcpGamma = RenderParams.z;\n\nvarying vec4 Surface; // (2d coords, invalidate, opacity)\nvarying vec4 Color_NegHorizSurfScale;\nvarying vec4 StrokeColor_Cutoff;\n\n// ---- Implementation\n\nfloat blendCoeff(vec2 edge0, vec2 edge1, vec2 x) {\n    vec2 weight = smoothstep(edge0, edge1, x);\n    return max(weight.x, weight.y);\n}\n\nvec3 gammaApply(vec3 color) {\n    return pow(clamp(color, 0.0, 1.0), vec3(gamma));\n}\n\nvec3 gammaCorrect(vec3 color) {\n    return pow(clamp(color, 0.0, 1.0), vec3(rcpGamma));\n}\n\n\nvoid main(void) {\n\n    if (Surface.z > 0.0) discard;\n\n    // Distance from center of surface coordinate (keep it this way;\n    // strangely the \'abs\' function does not work correctly on all\n    // platforms here)\n    vec2 dist = min(Surface.xy * sign(Surface.xy), 1.0);\n\n    // Determine thresholds in surface coordinates\n    //\n    // 0.0             1.0\n    // |-----------------|\n    // \n    // +--- extent ---+\n    //     incl. aa / 2  :\n    //                   :\n    //           |<------| stroke cutoff\n    //           :\n    //           |aa->\n    //           |---|\n    // inner edge min / max\n    // \n    //              |<-aa|\n    // outer edge min\n    //\n    float strokeCutoff = StrokeColor_Cutoff.w; // scaled stroke width\n\n#ifndef STANDARD_DERIVATIVES\n    vec2 negScale = vec2(Color_NegHorizSurfScale.w, \n                         -1.0 / max(strokeCutoff, antiAliasing));\n#else\n    // with this extension can determine the gradient length of\n    // each surface coordinate component in pixels\n    vec2 dSurfPixX = dFdx(Surface.xy), dSurfPixY = dFdy(Surface.xy);\n    vec2 negScale = vec2(-length(vec2(dSurfPixX.x, dSurfPixY.x)),\n                         -length(vec2(dSurfPixX.y, dSurfPixY.y)));\n#endif\n\n    vec2 negAntiAlias = negScale * antiAliasing;\n    vec2 innerEdgeMin = negScale * strokeCutoff + vec2(1.0);\n    vec2 innerEdgeMax = innerEdgeMin - negAntiAlias;\n    vec2 outerEdgeMin = negAntiAlias + vec2(1.0);\n\n    // Blend with stroke color (smooth, inner edge)\n    vec3 color = mix(Color_NegHorizSurfScale.rgb, StrokeColor_Cutoff.rgb,\n                     blendCoeff(innerEdgeMin, innerEdgeMax, dist));\n\n    // Adjust alpha for edge smoothing (outer edge)\n    float alpha = Surface.a  * (1.0 - blendCoeff(outerEdgeMin, vec2(1.0), dist));\n\n    // Gamma correct here (for now - we\'d ideally want to blend in \n    // a linearized color space)\n    color = gammaCorrect(color);\n\n#ifdef PREMULTIPLY_BY_ALPHA\n    color.rgb *= alpha;\n#endif\n\n    gl_FragColor = vec4(color, alpha);\n}\n\n';
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment.OPTIMIZED_SOURCE = 'precision mediump float;#define PREMULTIPLY_BY_ALPHA true\nprecision mediump float;uniform vec3 c;float g=c.x;float h=c.y;float i=c.z;varying vec4 d,e,f;float u(vec2 j,vec2 k,vec2 l){vec2 m=smoothstep(j,k,l);return max(m.x,m.y);}vec3 v(vec3 j){return pow(clamp(j,0.,1.),vec3(i));}void main(){if(d.z>0.)discard;vec2 j,o,p,q,r;j=min(d.xy*sign(d.xy),1.);float k,t;k=f.w;\n#ifndef STANDARD_DERIVATIVES\nvec2 l=vec2(e.w,-1./max(k,g));\n#else\nvec2 m,n,l;m=dFdx(d.xy);n=dFdy(d.xy);l=vec2(-length(vec2(m.x,n.x)),-length(vec2(m.y,n.y)));\n#endif\no=l*g;p=l*k+vec2(1);q=p-o;r=o+vec2(1);vec3 s=mix(e.rgb,f.rgb,u(p,q,j));t=d.a*(1.-u(r,vec2(1),j));s=v(s);\n#ifdef PREMULTIPLY_BY_ALPHA\ns.rgb*=t;\n#endif\ngl_FragColor=vec4(s,t);}';
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment.SOURCE = goog.DEBUG ?
    ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment.DEBUG_SOURCE :
    ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionFragment.OPTIMIZED_SOURCE;
/**
 * @constructor
 * @extends {ol.webgl.shader.Vertex}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex = function() {
  goog.base(this, ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex.SOURCE);
};
goog.inherits(ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex, ol.webgl.shader.Vertex);
goog.addSingletonGetter(ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex);
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex.DEBUG_SOURCE = '//! NAMESPACE=ol.renderer.webgl.vectorlayer2.shader.LineStringCollection\n//! CLASS=ol.renderer.webgl.vectorlayer2.shader.LineStringCollection\n\n\n//! COMMON\n//#version 100 // FIXME we should be able to uncomment this\n#define PREMULTIPLY_BY_ALPHA true\n\n\n//! VERTEX\n\n// ---- Configuration\n\nprecision highp float;\n\n// ---- Interface\n\nattribute vec2 PositionP;\nattribute vec2 Position0;\nattribute vec2 PositionN;\nattribute float Control;\n\nattribute vec4 Style;\n// width\n// color (rgb)\n// opacity (floor 0..255), outline width (fract)\n// stroke color (rgb)\n\n\nuniform mat4 Transform;\nuniform vec2 PixelScale;\n\nuniform vec3 RenderParams;\nfloat antiAliasing = RenderParams.x;\n//-float gamma = RenderParams.y; - used in fragment shader\n//-float rcpGamma = RenderParams.z; - used in fragment shader\n\nvarying vec4 Surface; // (2d coords, invalidate, opacity)\nvarying vec4 Color_NegHorizSurfScale;\nvarying vec4 StrokeColor_Cutoff;\n\n\n// ---- Implementation\n\nvec3 decodeRGB(float v) {\n\n    const float downshift16 = 1. / 65536.;\n    const float downshift8  = 1. /   256.;\n\n    return vec3(fract(v * downshift16), \n                fract(v * downshift8),\n                fract(v));\n}\n\nvec2 rotateCw(vec2 p) {\n    return vec2(p.y, -p.x);\n}\n\nvec3 perspDiv(vec4 p) {\n    return p.xyz / p.w;\n}\n\nvec2 safeNormalize(vec2 v) {\n    float frob = dot(v, v);\n    return v * (frob > 0.0 ? inversesqrt(frob) : 0.0);\n}\n\nvoid main(void) {\n\n    // Basic vertex shader operation\n    gl_Position = Transform * vec4(Position0, 0.0, 1.0);\n\n    Surface = vec4(0., 0., 0., 0.);\n    if (Control == 12.0) {\n        Surface.z = 1.0; // invalidate surface\n        return;\n    }\n\n    // Decode colors and opacity from style\n    Color_NegHorizSurfScale.rgb = decodeRGB(Style.y);\n    StrokeColor_Cutoff.rgb = decodeRGB(Style.w);\n    Surface.w = floor(Style.z) / 255.0;\n\n    // Decode line widths from style and prepare for rendering\n    float extent = Style.x * 0.5;\n    float actExtent = extent + antiAliasing * 0.5;\n    Color_NegHorizSurfScale.w = -1.0 / actExtent;\n    float strokeCutoff = fract(Style.z) * (extent + antiAliasing * 1.5);\n    StrokeColor_Cutoff.w = strokeCutoff;\n\n    // Done when not at edge, otherwise the above output\n    // provides default values assumed in the code below\n    if (Control == 0.0) return;\n\n    // TODO short circuiting can happen even earlier for entirely\n    // inner vertices of polygons, also have to extrude the ones\n    // at inner vertices of polygon edges\n\n    // Perform additional transforms\n    vec2 pN = perspDiv(Transform * vec4(PositionN, 0.0, 1.0)).xy;\n    vec2 p0 = perspDiv(gl_Position).xy;\n    vec2 pP = perspDiv(Transform * vec4(PositionP, 0.0, 1.0)).xy;\n\n    // Determine tangents of adjacent edges and at vertex\n    vec2 tP = safeNormalize(p0-pP);\n    vec2 tN = safeNormalize(pN-p0);\n    vec2 tangent = tP + tN;\n\n    vec2 displacement = vec2(0.0);\n\n    // Determine extrusion / surface coordinates in tangential direction\n    // (only at start/end of a line strip, indicated via control flags)\n    float ctrl = Control;\n    if (ctrl >= 4.0) {\n        // Vertical edge?\n\n        if (ctrl >= 8.0) {\n            ctrl -= 4.0; // bit removal - or half of it (see below)\n\n            // Tangent is in opposite direction - correect it\n            tangent = -tangent;\n\n            // Displacement towards the outside of the line\n            displacement = (tP - tN) * max(strokeCutoff, antiAliasing);\n\n            // Let surface coordinate indicate the edge (can use the\n            // same value for both ends as interpolating towards zero in\n            // all cases - subdivision is inherent)\n            Surface.y = 1.0;\n        }\n\n        // Tangent used as reference for mitering is either in opposite\n        // direction or zero - correct it\n        tP = tangent;\n\n        ctrl -= 4.0; // bit removal - done odd to ease data dependencies\n    }\n\n    // Determine extrusion / surface coordinate in normal directions\n    vec2 normal = normalize(rotateCw(tangent));\n    Surface.x = ctrl * 2.0 - 3.0;\n    float horizExtent = actExtent /\n            dot(rotateCw(tP), normal) *     // projected along miter\n            Surface.x;                      // sign: left or right\n\n    displacement += horizExtent * normal; \n    gl_Position.xy += gl_Position.w * displacement * PixelScale;\n}\n\n\n';
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex.OPTIMIZED_SOURCE = '#define PREMULTIPLY_BY_ALPHA true\nprecision highp float;attribute vec2 g,h,i;attribute float j;attribute vec4 k;uniform mat4 a;uniform vec2 b;uniform vec3 c;float l=c.x;varying vec4 d,e,f;vec3 z(float m){const float n=1./65536.;const float o=1./256.;return vec3(fract(m*n),fract(m*o),fract(m));}vec2 A(vec2 m){return vec2(m.y,-m.x);}vec3 B(vec4 m){return m.xyz/m.w;}vec2 C(vec2 m){float n=dot(m,m);return m*(n>0.?inversesqrt(n):0.);}void main(){gl_Position=a*vec4(h,0,1);d=vec4(0);if(j==12.){d.z=1.;return;}e.rgb=z(k.y);f.rgb=z(k.w);d.w=floor(k.z)/255.;float m,n,o,w,y;m=k.x*.5;n=m+l*.5;e.w=-1./n;o=fract(k.z)*(m+l*1.5);f.w=o;if(j==0.)return;vec2 p,q,r,s,t,u,v,x;p=B(a*vec4(i,0,1)).xy;q=B(gl_Position).xy;r=B(a*vec4(g,0,1)).xy;s=C(q-r);t=C(p-q);u=s+t;v=vec2(0);w=j;if(w>=4.){if(w>=8.){w-=4.;u=-u;v=(s-t)*max(o,l);d.y=1.;}s=u;w-=4.;}x=normalize(A(u));d.x=w*2.-3.;y=n/dot(A(s),x)*d.x;v+=y*x;gl_Position.xy+=gl_Position.w*v*b;}';
/**
 * @const
 * @type {string}
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex.SOURCE = goog.DEBUG ?
    ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex.DEBUG_SOURCE :
    ol.renderer.webgl.vectorlayer2.shader.LineStringCollectionVertex.OPTIMIZED_SOURCE;
/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 */
ol.renderer.webgl.vectorlayer2.shader.LineStringCollection.Locations = function(gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.Transform = gl.getUniformLocation(
      program, goog.DEBUG ? 'Transform' : 'a');
  /**
   * @type {WebGLUniformLocation}
   */
  this.PixelScale = gl.getUniformLocation(
      program, goog.DEBUG ? 'PixelScale' : 'b');
  /**
   * @type {WebGLUniformLocation}
   */
  this.RenderParams = gl.getUniformLocation(
      program, goog.DEBUG ? 'RenderParams' : 'c');
  /**
   * @type {number}
   */
  this.PositionP = gl.getAttribLocation(
      program, goog.DEBUG ? 'PositionP' : 'g');
  /**
   * @type {number}
   */
  this.Position0 = gl.getAttribLocation(
      program, goog.DEBUG ? 'Position0' : 'h');
  /**
   * @type {number}
   */
  this.PositionN = gl.getAttribLocation(
      program, goog.DEBUG ? 'PositionN' : 'i');
  /**
   * @type {number}
   */
  this.Control = gl.getAttribLocation(
      program, goog.DEBUG ? 'Control' : 'j');
  /**
   * @type {number}
   */
  this.Style = gl.getAttribLocation(
      program, goog.DEBUG ? 'Style' : 'k');
};
